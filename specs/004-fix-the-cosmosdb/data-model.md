# Data Model: Fix CosmosDB DateTime Query Format

**Feature**: 004-fix-the-cosmosdb  
**Date**: 2025-10-17  
**Related**: [spec.md](./spec.md), [research.md](./research.md)

## Overview

This fix does not introduce new data models. It modifies how existing datetime fields are queried while maintaining backward compatibility with stored formats.

## Existing Entities (No Changes)

### RedditPost

Existing Pydantic model - no changes required to model definition.

**Datetime Fields**:
- `created_utc: datetime` - When post was created on Reddit
- `collected_at: datetime` - When post was collected by our system

**Storage Format** (unchanged):
- Stored as ISO 8601 string: `"2025-10-17T14:53:28.639801Z"`
- Generated by: `datetime.isoformat()`

**Query Impact**:
- Queries filtering by `collected_at` or `created_utc` must use Unix timestamp parameters
- Stored format remains ISO 8601 for human readability

---

### RedditComment

Existing Pydantic model - no changes required to model definition.

**Datetime Fields**:
- `created_utc: datetime` - When comment was created on Reddit
- `collected_at: datetime` - When comment was collected by our system

**Storage Format** (unchanged):
- Same as RedditPost

---

### SentimentScore

Existing Pydantic model - no changes required to model definition.

**Datetime Fields**:
- `analyzed_at: datetime` - When sentiment analysis was performed

**Storage Format** (unchanged):
- Same as RedditPost

---

### TrendingTopic

Existing Pydantic model - no changes required to model definition.

**Datetime Fields**:
- `peak_time: datetime` - When topic had peak activity
- `created_at: datetime` - When topic record was created

**Storage Format** (unchanged):
- Same as RedditPost

## Query Parameter Format Change

### Current (Broken)

```python
cutoff = datetime.utcnow() - timedelta(hours=24)
parameters = [{"name": "@cutoff", "value": cutoff.strftime("%Y-%m-%dT%H:%M:%SZ")}]
# Results in: {"name": "@cutoff", "value": "2025-10-17T14:53:28Z"}
# ERROR: InternalServerError - '/' is invalid after a value
```

### New (Fixed)

```python
cutoff = datetime.utcnow() - timedelta(hours=24)
cutoff_timestamp = int(cutoff.timestamp())
parameters = [{"name": "@cutoff", "value": cutoff_timestamp}]
# Results in: {"name": "@cutoff", "value": 1729177108}
# SUCCESS: Integer parameter, no JSON parsing issues
```

## Comparison Approaches

### Option 1: Direct Timestamp Comparison (Recommended)

Add Unix timestamp field to stored documents:

```python
# When storing
item['collected_at'] = post.collected_at.isoformat()  # Keep for readability
item['collected_at_ts'] = int(post.collected_at.timestamp())  # Add for queries

# When querying
query = "SELECT * FROM c WHERE c.collected_at_ts >= @cutoff"
parameters = [{"name": "@cutoff", "value": int(cutoff.timestamp())}]
```

**Pros**:
- Fastest query performance
- No function overhead
- Can index on `_ts` field

**Cons**:
- Requires migration to add `_ts` suffix fields
- Increases document size slightly

### Option 2: Use Cosmos DB `_ts` System Field

Use built-in timestamp for modification time:

```python
# When querying
query = "SELECT * FROM c WHERE c._ts >= @cutoff"
parameters = [{"name": "@cutoff", "value": int(cutoff.timestamp())}]
```

**Pros**:
- No schema changes
- System-maintained field

**Cons**:
- Only tracks last modification, not collection time
- Different semantics than `collected_at`

### Option 3: Function-Based Conversion (Fallback)

Use UDF or built-in functions:

```python
# When querying
query = "SELECT * FROM c WHERE UNIX_TIMESTAMP(c.collected_at) >= @cutoff"
parameters = [{"name": "@cutoff", "value": int(cutoff.timestamp())}]
```

**Pros**:
- No schema changes
- Works with existing data

**Cons**:
- Function call overhead on every query
- May not be indexable
- Cosmos DB may not support UNIX_TIMESTAMP function

## Recommended Approach

**Use Option 1** (Direct Timestamp Comparison):

1. **Migration Phase** (Gradual):
   - Add `_ts` suffix fields when saving new documents
   - Backfill existing documents lazily (update on read/write)
   - Keep ISO format for human readability

2. **Query Phase**:
   - Use `_ts` fields for filtering
   - Fall back to `_ts` system field if custom field not present
   - Eventually deprecate queries on ISO format fields

3. **Implementation**:
   ```python
   def save_post(self, post: RedditPost):
       item = post.model_dump()
       item['id'] = post.id
       item['created_utc'] = post.created_utc.isoformat()
       item['created_utc_ts'] = int(post.created_utc.timestamp())  # NEW
       item['collected_at'] = post.collected_at.isoformat()
       item['collected_at_ts'] = int(post.collected_at.timestamp())  # NEW
       # ... rest of save logic
   ```

## Validation Rules (Unchanged)

All existing Pydantic validation rules remain:
- Datetime fields must be valid datetime objects
- UTC timezone assumed
- Microsecond precision preserved in ISO format

## Migration Strategy

**Phase 1: Additive** (This PR)
- Add `_ts` suffix fields to save methods
- Update query methods to use timestamp parameters
- Keep ISO format fields for backward compatibility
- No breaking changes

**Phase 2: Backfill** (Future PR if needed)
- Script to add `_ts` fields to existing documents
- Only if query performance becomes issue
- Can be done lazily

**Phase 3: Cleanup** (Future PR, optional)
- After 100% of documents have `_ts` fields
- Remove ISO format queries
- Keep ISO format for human readability in documents

## Impact Summary

| Component | Change | Risk |
|-----------|--------|------|
| Models | None | None - Pydantic models unchanged |
| Storage | Add `_ts` fields (optional) | Low - additive only |
| Queries | Use int parameters | Low - fixes existing bug |
| API | None | None - internal change only |
| Tests | Add integration tests | None - improves coverage |
